# Muid Specification

This document describes three semantically equivalant
formats for muids:

* A tuple/proto/stuct representation in which
  the muid is a triplet of numbers (those three being
  timestamp, medallion, and offset, described below)

* A "packed" 128 bit representation.  This binary
  format comes from encoding the three numbers
  into specific bit ranges in big-endian order.
  Sorting these packed representations by bytes
  will also sort them according to the tuple of
  three component numbers.

  Note that the packed representation is primarily
  for internal use to store muids in the database
  without taking up too much space.  It's expected
  that other implementations of the Gink protocol
  may use a different packing approach.

This specification is heavily inspired by ULID
(https://github.com/ulid/spec) in that it intends to
specify a scheme for identifiers that can be ordered,
increase over time, and very likely to be unique,
and fit into 128 bits.

Muids have some additional objectives, however.
For one, we'd like to be able to keep track of
the database node that created a given muid.
Each node in the database will only create objects
with a monotonically increasing time and identifiers.
We may not receive an update from a distant node until well
after it was created, so will have trouble keeping *all*
updates in order, but separating them out by node source
will allow us to keep the updates from each node in order.

Secondly we'd like to be able to specify that a set of updates
from a node should be treated as happening all together
(in a single atomic transaction).  Since all of these updates
will share the same timestamp and node identifier, some additional
bits need to be used to distinguish between the various updates
within a transaction.  To ensure that all updates within one
transaction are either before or after all updates from another,
the order of components will be: [timestamp, medallion, offset].

# Timestamp
As the name implies, muids have microsecond time resolution.

In terms of the packed format, the first 13 hex digits
number of microseconds since epoch, encoded big-endian.
This will ensure that lexical comparisons of muids will sort
according to time.  As an example, I see the (fractional) unix time
as of this writing to be 1642579230.975519 (generated by python's time.time()).
That corresponds to 1642579230975519 microseconds with hex digits
'5D5EAC793E61F'.  Note that this current packed representation only
supports timestamps up to the year 2112; after that implementations
ought to have transferred over to a different packed representation.


# Medallion
Each node in the system has a unique integer to identify it.
These must always be less than 17592186044415 in order to not
break the storage system currently used.  And furthermore,
for the time being, muids are only assigned randomly and
must be in the range:
1099511627776 to 2199023255552 (0x10000000000 to 0x1FFFFFFFFFF)

Numbers in this range will always have exactly 11 hex digits.
For example, one medallion randomly selected from that range could be
1923190821165, which has the hex sequence `1BFC71B112D`.

Though this initial version specifies that the first hex digit should
always be '1', future versions may allow for different digits, so
implementations should allow medallions up to the maximum value.

# Offset
A full 4 bytes (8 hex digits) are reserved for the offset, effectively
allowing any given transaction to have more than a billion changes in it.
(Negative offsets are used to reference items within one transaction).

# Combined String Representation
Concatenating all of the upper case hex digits in the order:
timestamp, medallion, offset together produces the cononical string representation.
If the offset is 0 it may be omitted, and if both the offset and medallion are 0
they may both be omitted.

For example, combining the values from the prior explinations would give a muid who's string
representation is `5D5EAC793E61F-1BFC71B112D-0000000B`.

Replacing the offset with 0 (representing the containing transaction) would give
the muid `5D5EAC793E61F-1BFC71B112D-0000000B` that could also be written
`5D5EAC793E61F-1BFC71B112D`.

Replacing both the offset and transaction numbers with 0 would result in a muid
who's representation would be `5D5EAC793E61F-0000000000000-00000` or
`5D5EAC793E61F-0000000000000` or `5D5EAC793E61F`.
